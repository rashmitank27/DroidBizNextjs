{"id":"blogs","name":"Blogs","base_url":"/blogs","content":[{"id":1,"title":"Android","url":"android-15-behavior-changes-apps-targeting-android-15-or-higher","type":1,"content":"# Android 15 Behavior Changes: Essential Guide for Apps Targeting Android 15 (API Level 35)\r\n\r\nIf you’re developing an Android app and planning to target Android 15 (API level 35), you need to understand the critical **Android 15 behavior changes** that will affect your application. These **Android 15 behavior changes** are mandatory for apps targeting Android 15 and can significantly impact how your app functions. This comprehensive guide covers all the essential **Android 15 behavior changes** you must implement when your app targets Android 15 or higher.\r\n\r\n## Understanding Android 15 Behavior Changes\r\n\r\n**Android 15 behavior changes** are modifications that exclusively apply to apps targeting Android 15 (API level 35) or higher. Unlike system-wide changes that affect all apps, these **Android 15 behavior changes** only impact applications that explicitly set their `targetSdkVersion` to 35. When you update your app to target Android 15, you must adapt to these **Android 15 behavior changes** to ensure proper functionality.\r\n\r\nThe **Android 15 behavior changes** span across multiple areas including foreground services, security enhancements, user interface modifications, and core system functionality. Each of these **Android 15 behavior changes** requires specific implementation adjustments in your codebase.\r\n\r\n## Core Functionality Changes in Android 15\r\n\r\n### Foreground Service Timeout Behavior\r\n\r\nOne of the most significant **Android 15 behavior changes** involves foreground service timeout restrictions. Android 15 introduces new timeout behavior for `dataSync` foreground services that directly affects apps targeting Android 15.\r\n\r\n**DataSync Timeout Properties:**\r\n\r\n- **Timeout Duration**: 6 hours in a 24-hour period\r\n- **Callback Method**: `Service.onTimeout(int, int)`\r\n- **Required Action**: Call `stopSelf()` within seconds\r\n- **Exception Type**: `RemoteServiceException` if timeout not handled\r\n\r\nWhen your `dataSync` foreground service reaches the 6-hour limit, Android 15 calls the `onTimeout()` method. Your service must implement this method and call `stopSelf()` immediately to avoid system exceptions.\r\n\r\n```kotlin\r\nclass MyDataSyncService : Service() {\r\n    override fun onTimeout(startId: Int, fgsType: Int) {\r\n        // Handle timeout for Android 15 behavior changes\r\n        Log.w(\"ServiceTimeout\", \"DataSync service timeout reached\")\r\n        stopSelf() // Required to prevent RemoteServiceException\r\n    }\r\n}\r\n```\r\n\r\n### Media Processing Foreground Service Type\r\n\r\nAndroid 15 introduces a new foreground service type called `mediaProcessing` as part of the **Android 15 behavior changes**. This service type is designed for operations like transcoding media files, converting audio formats, or processing video content.\r\n\r\n**MediaProcessing Service Properties:**\r\n\r\n- **Service Type**: `mediaProcessing`\r\n- **Timeout Duration**: 6 hours in 24-hour period\r\n- **Use Cases**: Media transcoding, format conversion, audio processing\r\n- **Timeout Handling**: Same `onTimeout()` callback as dataSync\r\n\r\nThe `mediaProcessing` service follows the same timeout rules as `dataSync` services. When the 6-hour limit is reached, your service receives the `onTimeout()` callback and must call `stopSelf()`.\r\n\r\n```kotlin\r\n// AndroidManifest.xml declaration\r\n<service android:name=\".MediaProcessingService\"\r\n    android:foregroundServiceType=\"mediaProcessing\" />\r\n```\r\n\r\n### BOOT_COMPLETED Broadcast Restrictions\r\n\r\n**Android 15 behavior changes** include new restrictions on `BOOT_COMPLETED` broadcast receivers launching foreground services. Apps targeting Android 15 cannot launch specific foreground service types from `BOOT_COMPLETED` receivers.\r\n\r\n**Restricted Service Types from BOOT_COMPLETED:**\r\n\r\n- `dataSync`\r\n- `camera`\r\n- `mediaPlayback`\r\n- `phoneCall`\r\n- `mediaProjection`\r\n- `microphone`\r\n\r\nIf your `BOOT_COMPLETED` receiver attempts to launch any of these restricted service types, the system throws `ForegroundServiceStartNotAllowedException`.\r\n\r\n```kotlin\r\nclass BootCompletedReceiver : BroadcastReceiver() {\r\n    override fun onReceive(context: Context, intent: Intent) {\r\n        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {\r\n            // This will throw ForegroundServiceStartNotAllowedException\r\n            // for restricted service types in Android 15\r\n            val serviceIntent = Intent(context, DataSyncService::class.java)\r\n            context.startForegroundService(serviceIntent) // Fails for dataSync type\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### SYSTEM_ALERT_WINDOW Permission Changes\r\n\r\nAnother critical aspect of **Android 15 behavior changes** involves restrictions on starting foreground services while holding the `SYSTEM_ALERT_WINDOW` permission. Previously, apps with this permission could launch foreground services from the background, but Android 15 narrows this exemption.\r\n\r\n**New SYSTEM_ALERT_WINDOW Requirements:**\r\n\r\n- **Permission Required**: `SYSTEM_ALERT_WINDOW`\r\n- **Additional Requirement**: Visible overlay window\r\n- **Window Type**: `TYPE_APPLICATION_OVERLAY`\r\n- **Visibility Check**: `View.getWindowVisibility()`\r\n\r\nYour app must have both the permission AND a visible overlay window before starting a foreground service from the background.\r\n\r\n```kotlin\r\nfun startForegroundServiceWithOverlay() {\r\n    // Check if overlay window is visible before starting service\r\n    if (overlayView.windowVisibility == View.VISIBLE) {\r\n        val serviceIntent = Intent(this, MyForegroundService::class.java)\r\n        startForegroundService(serviceIntent)\r\n    } else {\r\n        Log.e(\"ServiceStart\", \"Cannot start service - overlay not visible\")\r\n    }\r\n}\r\n```\r\n\r\n## Security Enhancements in Android 15\r\n\r\n### Do Not Disturb Policy Changes\r\n\r\n**Android 15 behavior changes** modify how apps can interact with Do Not Disturb (DND) mode. Apps targeting Android 15 can no longer change the global DND state directly but must contribute an `AutomaticZenRule` instead.\r\n\r\n**DND Policy Properties:**\r\n\r\n- **Global State Control**: Removed for apps targeting Android 15\r\n- **Alternative Approach**: `AutomaticZenRule` contribution\r\n- **Policy Combination**: Most-restrictive-policy-wins scheme\r\n- **Affected APIs**: `setInterruptionFilter()`, `setNotificationPolicy()`\r\n\r\nWhen your app calls previously available DND APIs, the system creates an implicit `AutomaticZenRule` instead of changing global settings.\r\n\r\n```kotlin\r\nfun configureDNDRule() {\r\n    val notificationManager = getSystemService(NotificationManager::class.java)\r\n    \r\n    // This creates an AutomaticZenRule in Android 15\r\n    // instead of changing global DND state\r\n    notificationManager.setInterruptionFilter(\r\n        NotificationManager.INTERRUPTION_FILTER_PRIORITY\r\n    )\r\n}\r\n```\r\n\r\n### TLS Version Restrictions\r\n\r\nSecurity-focused **Android 15 behavior changes** include restrictions on TLS versions 1.0 and 1.1. Apps targeting Android 15 cannot use these deprecated TLS versions, which were previously deprecated but not blocked.\r\n\r\n**TLS Restriction Properties:**\r\n\r\n- **Blocked Versions**: TLS 1.0 and TLS 1.1\r\n- **Minimum Required**: TLS 1.2 or higher\r\n- **Impact Area**: Network communication, HTTPS connections\r\n- **Migration Required**: Update network security configuration\r\n\r\nEnsure your app’s network connections use TLS 1.2 or higher to comply with these **Android 15 behavior changes**.\r\n\r\n## OpenJDK API Changes\r\n\r\n### String Formatting Validation\r\n\r\n**Android 15 behavior changes** include stricter validation for string formatting APIs. The `String.format()` and `Formatter.format()` methods now perform more rigorous validation of argument indices, flags, width, and precision.\r\n\r\n**String Format Properties:**\r\n\r\n- **Stricter Validation**: Argument index, flags, width, precision\r\n- **Invalid Index Example**: `%0` (should be `%1`)\r\n- **Exception Type**: `IllegalFormatArgumentIndexException`\r\n- **Affected Methods**: `String.format()`, `Formatter.format()`\r\n\r\n```kotlin\r\n// This throws IllegalFormatArgumentIndexException in Android 15\r\nval invalidFormat = String.format(\"Value: %0\", \"test\")\r\n\r\n// Correct format for Android 15 behavior changes\r\nval validFormat = String.format(\"Value: %1\", \"test\")\r\n```\r\n\r\n### Arrays.asList().toArray() Changes\r\n\r\nThe component type behavior of `Arrays.asList(...).toArray()` has changed in **Android 15 behavior changes**. The resulting array now has `Object` as the component type instead of the underlying array element type.\r\n\r\n**Array Conversion Properties:**\r\n\r\n- **Old Behavior**: Component type matches element type\r\n- **New Behavior**: Component type is `Object`\r\n- **Exception**: `ClassCastException` when casting\r\n- **Solution**: Use `Collection.toArray(Object[])`\r\n\r\n```kotlin\r\n// This throws ClassCastException in Android 15\r\nval elements = Arrays.asList(\"one\", \"two\").toArray() as Array<String>\r\n\r\n// Correct approach for Android 15 behavior changes\r\nval elements = Arrays.asList(\"one\", \"two\").toArray(arrayOfNulls<String>(0))\r\n```\r\n\r\n### Locale Language Code Handling\r\n\r\n**Android 15 behavior changes** affect how locale language codes are handled. The system no longer converts Hebrew, Yiddish, and Indonesian language codes to their obsolete forms.\r\n\r\n**Language Code Properties:**\r\n\r\n- **Hebrew**: Use `he` instead of `iw`\r\n- **Yiddish**: Use `yi` instead of `ji`\r\n- **Indonesian**: Use `id` instead of `in`\r\n- **Standard**: ISO 639-1 codes required\r\n\r\n```kotlin\r\n// Updated for Android 15 behavior changes\r\nval hebrewLocale = Locale(\"he\", \"IL\") // Not \"iw\"\r\nval yiddishLocale = Locale(\"yi\", \"\") // Not \"ji\"\r\nval indonesianLocale = Locale(\"id\", \"ID\") // Not \"in\"\r\n```\r\n\r\n## SequencedCollection API Impact\r\n\r\n### Kotlin Extension Function Conflicts\r\n\r\nOne of the significant **Android 15 behavior changes** involves the new `SequencedCollection` API conflicting with Kotlin extension functions. When you set `compileSdk` to 35, the Kotlin compiler resolves `removeFirst()` and `removeLast()` calls to the new Java List APIs instead of Kotlin stdlib extensions.\r\n\r\n**SequencedCollection Properties:**\r\n\r\n- **Conflicting Methods**: `removeFirst()`, `removeLast()`\r\n- **Compiler Behavior**: Resolves to Java APIs\r\n- **Runtime Error**: `NoSuchMethodError` on older Android versions\r\n- **Lint Detection**: NewApi lint option catches these usages\r\n\r\n```kotlin\r\n// This causes NoSuchMethodError on Android 14 and lower\r\nlist.removeFirst() // Resolves to Java API in Android 15\r\n\r\n// Safe alternative for Android 15 behavior changes\r\nlist.removeAt(0) // Works on all Android versions\r\nlist.removeAt(list.lastIndex) // Works on all Android versions\r\n```\r\n\r\n### Java Method Signature Collisions\r\n\r\n**Android 15 behavior changes** can cause build-time errors when new methods in existing interfaces collide with methods in your custom implementations.\r\n\r\n**Collision Properties:**\r\n\r\n- **Affected Interfaces**: `List`, `Deque`\r\n- **New Methods**: `removeFirst()`, `removeLast()`, `reversed()`, `getFirst()`\r\n- **Error Type**: Incompatible return types, unrelated defaults\r\n- **Solution**: Override methods with compatible return types\r\n\r\n```kotlin\r\n// This causes build error in Android 15\r\nclass MyList : List<String> {\r\n    fun removeFirst() { } // Incompatible return type\r\n}\r\n\r\n// Correct implementation for Android 15 behavior changes\r\nclass MyList : List<String> {\r\n    override fun removeFirst(): String {\r\n        return super.removeFirst()\r\n    }\r\n}\r\n```\r\n\r\n## User Interface Changes\r\n\r\n### Edge-to-Edge Enforcement\r\n\r\n**Android 15 behavior changes** make edge-to-edge display the default for apps targeting Android 15. This change affects how your app’s UI renders behind system bars and can break existing layouts if not properly handled.\r\n\r\n**Edge-to-Edge Properties:**\r\n\r\n- **Default Behavior**: Enforced for apps targeting Android 15\r\n- **Navigation Bar**: Transparent by default\r\n- **Status Bar**: Transparent by default\r\n- **Content Drawing**: Behind system bars unless insets applied\r\n- **Display Cutout**: `LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS` required\r\n\r\nThe edge-to-edge enforcement affects multiple UI components and requires careful handling of window insets to prevent content from being drawn behind system UI elements.\r\n\r\n```kotlin\r\n// Handle window insets for Android 15 behavior changes\r\nViewCompat.setOnApplyWindowInsetsListener(view) { v, insets ->\r\n    val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())\r\n    v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)\r\n    insets\r\n}\r\n```\r\n\r\n### Configuration Size Changes\r\n\r\n**Android 15 behavior changes** modify how the `Configuration` class reports screen sizes. The configuration no longer excludes system bars from size calculations, which can affect layout calculations that depend on these values.\r\n\r\n**Configuration Properties:**\r\n\r\n- **Size Calculation**: Now includes system bars\r\n- **Affected Fields**: `screenWidthDp`, `screenHeightDp`, `smallestScreenWidthDp`\r\n- **Deprecated APIs**: `Display.getSize()`, `Display.getMetrics()`\r\n- **Alternatives**: `WindowMetricsCalculator`, `WindowInsets`, appropriate `ViewGroup`\r\n\r\n```kotlin\r\n// Avoid using Configuration for layout calculation\r\nval config = resources.configuration\r\nval screenWidth = config.screenWidthDp // Now includes system bars\r\n\r\n// Use WindowMetrics for Android 15 behavior changes\r\nval windowMetrics = WindowMetricsCalculator.getOrCreate()\r\n    .computeCurrentWindowMetrics(this)\r\nval bounds = windowMetrics.bounds\r\n```\r\n\r\n### TextView Changes\r\n\r\n**Android 15 behavior changes** include modifications to `TextView` behavior for better text rendering and internationalization support.\r\n\r\n**ElegantTextHeight Default:**\r\n\r\n- **Default Value**: `true` for apps targeting Android 15\r\n- **Impact**: Improved readability for complex scripts\r\n- **Affected Scripts**: Arabic, Lao, Myanmar, Tamil, Gujarati, Kannada, Malayalam, Odia, Telugu, Thai\r\n- **Fallback**: Can be set to `false` for backward compatibility\r\n\r\n**Width Allocation Changes:**\r\n\r\n- **Complex Letters**: Better space allocation for cursive fonts\r\n- **API Control**: `setUseBoundsForWidth()`, `setShiftDrawingOffsetForStartOverhang()`\r\n- **Padding Options**: Extra left padding to prevent clipping\r\n- **Default Behavior**: More width allocated automatically\r\n\r\n```kotlin\r\n// Configure TextView for Android 15 behavior changes\r\ntextView.setUseBoundsForWidth(true)\r\ntextView.setShiftDrawingOffsetForStartOverhang(true)\r\n```\r\n\r\n### EditText Locale-Aware Line Height\r\n\r\n**Android 15 behavior changes** introduce locale-aware default line height for `EditText` elements. The system now reserves minimum line height based on the locale’s reference font.\r\n\r\n**Locale Line Height Properties:**\r\n\r\n- **Behavior**: Minimum line height matches locale font\r\n- **Impact**: Different heights for different languages\r\n- **Control Attribute**: `useLocalePreferredLineHeightForMinimum`\r\n- **Custom API**: `setMinimumFontMetrics()`\r\n\r\n```kotlin\r\n// Disable locale-aware line height if needed\r\neditText.useLocalePreferredLineHeightForMinimum = false\r\n\r\n// Or set custom minimum font metrics\r\nval builder = DynamicLayout.Builder.obtain(text, textPaint, width)\r\nbuilder.setMinimumFontMetrics(customFontMetrics)\r\n```\r\n\r\n## Camera and Media Restrictions\r\n\r\n### Audio Focus Requirements\r\n\r\n**Android 15 behavior changes** introduce stricter requirements for requesting audio focus. Apps targeting Android 15 must be the top app or running a foreground service to successfully request audio focus.\r\n\r\n**Audio Focus Properties:**\r\n\r\n- **Requirements**: Top app OR foreground service running\r\n- **Return Value**: `AUDIOFOCUS_REQUEST_FAILED` if requirements not met\r\n- **Impact**: Background apps cannot gain audio focus\r\n- **Use Case**: Prevents unauthorized audio interruption\r\n\r\n```kotlin\r\nfun requestAudioFocus(): Boolean {\r\n    val audioManager = getSystemService(AudioManager::class.java)\r\n    val request = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)\r\n        .setAudioAttributes(audioAttributes)\r\n        .setOnAudioFocusChangeListener(focusChangeListener)\r\n        .build()\r\n    \r\n    val result = audioManager.requestAudioFocus(request)\r\n    return result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED\r\n}\r\n```\r\n\r\n## Testing Android 15 Behavior Changes\r\n\r\n### ADB Commands for Testing\r\n\r\nYou can test **Android 15 behavior changes** on your app even before targeting Android 15 by using specific ADB commands to enable individual behavior changes.\r\n\r\n**Foreground Service Timeout Testing:**\r\n\r\n```bash\r\n# Enable data sync timeouts\r\nadb shell am compat enable FGS_INTRODUCE_TIME_LIMITS your-package-name\r\n\r\n# Adjust timeout duration for testing\r\nadb shell device_config put activity_manager data_sync_fgs_timeout_duration 60000\r\n```\r\n\r\n**BOOT_COMPLETED Restrictions Testing:**\r\n\r\n```bash\r\n# Enable boot completed restrictions\r\nadb shell am compat enable FGS_BOOT_COMPLETED_RESTRICTIONS your-package-name\r\n\r\n# Send BOOT_COMPLETED broadcast for testing\r\nadb shell am broadcast -a android.intent.action.BOOT_COMPLETED your-package-name\r\n```\r\n\r\n**SYSTEM_ALERT_WINDOW Testing:**\r\n\r\n```bash\r\n# Enable system alert window restrictions\r\nadb shell am compat enable FGS_SAW_RESTRICTIONS your-package-name\r\n```\r\n\r\n### StrictMode for Intent Validation\r\n\r\nUse `StrictMode` to detect unsafe intent launches related to **Android 15 behavior changes** in intent security.\r\n\r\n```kotlin\r\n// Enable StrictMode for intent validation\r\nStrictMode.setVmPolicy(\r\n    StrictMode.VmPolicy.Builder()\r\n        .detectUnsafeIntentLaunch()\r\n        .build()\r\n)\r\n```\r\n\r\n## Implementation Strategy for Android 15 Behavior Changes\r\n\r\n### Migration Planning\r\n\r\nWhen adapting your app to **Android 15 behavior changes**, follow a systematic approach:\r\n\r\n1. **Identify Impact Areas**: Review each category of **Android 15 behavior changes**\r\n1. **Test Individual Changes**: Use ADB commands to test specific behaviors\r\n1. **Update Code Incrementally**: Implement changes in logical groups\r\n1. **Validate Functionality**: Ensure all features work correctly\r\n1. **Performance Testing**: Verify no performance regressions\r\n\r\n### Backward Compatibility\r\n\r\nMany **Android 15 behavior changes** allow you to maintain backward compatibility while supporting the new requirements:\r\n\r\n```kotlin\r\n// Example of handling both old and new behavior\r\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.VANILLA_ICE_CREAM) {\r\n    // Android 15 behavior changes implementation\r\n    handleEdgeToEdgeDisplay()\r\n} else {\r\n    // Legacy behavior for older versions\r\n    handleTraditionalDisplay()\r\n}\r\n```\r\n\r\n### Dependency Updates\r\n\r\nSome **Android 15 behavior changes** require updating your dependencies to compatible versions:\r\n\r\n- **Core Splashscreen**: Update to 1.2.0-alpha01 or later\r\n- **Compose Material**: Update for inset handling improvements\r\n- **AndroidX Libraries**: Ensure compatibility with Android 15\r\n\r\nThe **Android 15 behavior changes** represent significant modifications to the Android platform that require careful consideration and implementation. By understanding each category of changes and implementing the necessary adaptations, you can ensure your app functions correctly when targeting Android 15. Remember to test thoroughly using the provided ADB commands and validate your implementation across different device configurations.\r\n\r\nFor the most up-to-date information about **Android 15 behavior changes**, always refer to the [official Android developer documentation](https://developer.android.com/about/versions/15/behavior-changes-15) and test your app thoroughly on Android 15 devices.\r\n","keywords":"Android 15 behavior changes, Android 15 API level 35, foreground service timeout, edge-to-edge Android 15, Android 15 targetSdkVersion, OpenJDK Android 15, Android 15 security changes, SequencedCollection Android 15, Android 15 UI changes, Android 15 app compatibility​​​​​​​​​​​​​​​​","titleTag":"Android 15 Behavior Changes: Apps targeting Android 15 or higher","descriptionTag":"Essential guide to Android 15 behavior changes for apps targeting API level 35. Learn foreground service timeouts, edge-to-edge UI, OpenJDK updates, security restrictions, and testing methods to ensure compatibility.","shortDesc":"Android 15 Behavior Changes: Essential Guide for Apps Targeting Android 15 (API Level 35) If you’re developing an Android app and planning to target Androi...","lastModified":"2025-07-28T02:09:27.242Z"}],"keywords":"Android 15 behavior changes, Android 15 API level 35, foreground service timeout, edge-to-edge Android 15, Android 15 targetSdkVersion, OpenJDK Android 15, Android 15 security changes, SequencedCollection Android 15, Android 15 UI changes, Android 15 app compatibility​​​​​​​​​​​​​​​​","titleTag":"Android 15 Behavior Changes: Apps targeting Android 15 or higher","descriptionTag":"Essential guide to Android 15 behavior changes for apps targeting API level 35. Learn foreground service timeouts, edge-to-edge UI, OpenJDK updates, security restrictions, and testing methods to ensure compatibility.","totalPages":1,"lastUpdated":"2025-07-28T02:09:27.242Z"}