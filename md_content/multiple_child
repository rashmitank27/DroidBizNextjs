/n```/nCenter(/n/tchild: Row(/n/t/tchildren: [/n/t/t/tExpanded(/n/t/t/t/tflex: 2,/n/t/t/t/tchild: Container(/n/t/t/t/t/t/tcolor: Colors.blue,/n/t/t/t/t/t/theight: 100,/n/t/t/t/t/t/twidth: 100,/n/t/t/t/t)),/n/t/t/tExpanded(/n/t/t/t/tflex: 3,/n/t/t/t/tchild: Container(/n/t/t/t/t/tcolor: Colors.orange,/n/t/t/t/t/theight: 100,/n/t/t/t/t/twidth: 100/n/t/t/t/t),/n/t/t/t),/n/t/t/tExpanded(/n/t/t/t/tflex: 4,/n/t/t/t/tchild: Container(/n/t/t/t/t/tcolor: Colors.blue,/n/t/t/t/t/t/theight: 100,/n/t/t/t/t/t/twidth: 100/n/t/t/t/t),/n/t/t/t),/n/t/t],/n/t),/n)/n```/n#### 1) Row  /nRow is a layout widget in flutter which aligns its children horizontally. It can have multiple child widgets. Child widget can also be a Row or Column widget. Children of Row widget are not scrollable. If you want scrollable widgets then use ListView. If we add a large number of children in Row widget which can not be fit in Row then we see an overflow message.   /nConstructor:  /n```/nRow({     /nKey key,     /nMainAxisAlignment mainAxisAlignment: MainAxisAlignment.start,     /nMainAxisSize mainAxisSize: MainAxisSize.max,     /nCrossAxisAlignment crossAxisAlignment: CrossAxisAlignment.center,     /nTextDirection textDirection,     /nVerticalDirection verticalDirection: VerticalDirection.down,     /nTextBaseline textBaseline,     /nList<Widget> children: const [] /n}) /n``` /nmainAxisAlignment property runs horizontally and crossAxisAlignment property runs vertically.  /nHere is different properties explained for main axis and cross axis alignment:  /n+ start: it will align children at the start of the axis direction. /n+ center: It will align children at the center of the axis. /n+ end: It will align children at the end of the axis. /n+ spaceBetween: It will add space between children evenly. /n+ spaceAround:It will add the space between the children evenly and half of that space before and after the first and last children widget. /n+ spaceEvenly: It will add the space between the children evenly and before and after the first and last children widget.  /n#### 2) Column /nColumn is a layout widget in flutter which aligns its children vertically. It can have multiple child widgets. Child widget can also be a Row or Column widget. Children of Column widget are not scrollable. If you want scrollable widgets then use ListView. If we add a large number of children in Column widget which can not be fit in column then we see an overflow message.  /nConstructor: /n``` /nColumn(     {/nKey key,     /nMainAxisAlignment mainAxisAlignment: MainAxisAlignment.start,     /nMainAxisSize mainAxisSize: MainAxisSize.max,     /nCrossAxisAlignment crossAxisAlignment: CrossAxisAlignment.center,     /nTextDirection textDirection,     /nVerticalDirection verticalDirection: VerticalDirection.down,     /nTextBaseline textBaseline,     /nList<Widget> children: const <Widget>[]/n} ) /n``` /nHere is different properties explained for main axis and cross axis alignment:  /n+ start: it will align children at the start of the axis direction. /n+ center: It will align children at the center of the axis. /n+ end: It will align children at the end of the axis. /n+ spaceBetween: It will add space between children evenly. /n+ spaceAround: It will add the space between the children evenly and half of that space before and after the first and last children widget. /n+ spaceEvenly: It will add the space between the children evenly and before and after the first and last children widget.  /n#### 3) Expanded /nExpanded works with Flex/Flexbox layout and is great for distributing space between multiple items. It expands the child of the Row, Column or Flex widget such that the child fills maximum available space.  /nExample:   /n``` /nCenter(/nchild: /nRow(/nchildren: <Widget>[            /nContainer(              /ncolor: Colors.blue,              /nheight: 100,              /nwidth: 100,            /n),            /nExpanded(              /nchild: Container(                /ncolor: Colors.orange,                /nheight: 100,              /n),            /n),            /nContainer(              /ncolor: Colors.blue,              /nheight: 100,              /nwidth: 100,            /n),          /n],        /n),    /n) /n``` /n#### 4) ListView /nA scrollable list of widgets arranged linearly. It shows children one by one in a scrollable direction. when we want to create a list recursively without writing code again and again then ListView.builder is used instead of ListView.  /nConstructor of ListView:  /n``` /nCenter(        child: Row(          children: <Widget>[            Expanded(              flex: 2,              child: Container(      color: Colors.blue,      height: 100,      width: 100,            )),            Expanded(              flex: 3,              child: Container(                color: Colors.orange,                height: 100,      width: 100              ),            ),            Expanded(              flex: 4,              child: Container(                color: Colors.blue,                   height: 100,      width: 100              ),            ),          ],        ),    )    /n```    /nExample of ListView:  /n``` ListView(        children: <Widget>[          Text('Sunday'),          Text('Monday'),          Text('Tuesday'),        ],      ) ``` /nThe above constructor is useful for a small size of list because it takes List as children. To work with lists having a large number of items, we need to use ListView.builder. The difference between ListView and ListView.builder is that ListView creates all items at once whereas ListView.builder creates items when they are scrolled onto the screen.  /n``` ListView.builder({     Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     double itemExtent,     @required IndexedWidgetBuilder itemBuilder,     int itemCount,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge }) ```  /nThe ListView.builder constructor takes an IndexedWidgetBuilder, which builds the children on demand.  /nExample:  /n``` final List<String> entries = <String>['A', 'B', 'C'];  ListView.builder(        itemCount: entries.length,        itemBuilder: (BuildContext context, int index) {       return Text('${entries[index]}');   } ) ``` /nSimilarly ListView.separated is useful when you want to add a separator in between children of the List.  /nConstructor of ListView.separated:  /n``` ListView.separated({     Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required IndexedWidgetBuilder itemBuilder,     @required IndexedWidgetBuilder separatorBuilder,     @required int itemCount,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge }) ```  /nThe ListView.separated constructor takes two IndexedWidgetBuilders: itemBuilder builds child items on demand, and separatorBuilder similarly builds separator children which appear in between the child items. This constructor is appropriate for list views with a fixed number of children.  /nExample: /n``` final List<String> entries = <String>['A', 'B', 'C'];  ListView.separated(  itemCount: entries.length,  itemBuilder: (BuildContext context, int index) {    return Container(      height: 50,      color: Colors.orange,      child: Center(child: Text('${entries[index]}')),    );  },  separatorBuilder: (BuildContext context, int index) => const Divider(), ); ```  /n##### Horizontal ListView: /nTo create horizontal ListView, specify scrollDirection as horizontal.  /nExample:  /n``` ListView.builder(        scrollDirection: Axis.horizontal,        itemBuilder: (context, index) {          return Container(            margin: const EdgeInsets.symmetric(horizontal: 1.0),            color: Colors.tealAccent,            child: Text('$index'),          );        },      ) ``` /n#### 5) GridView /nGridView is a scrollable 2D array of widgets. The main axis direction of a grid is the direction in which it scrolls. We can define the direction only in which it can scroll using scrollDirection property.  /nThe most frequently used grid layout is GridView.count /n##### i) GridView.count: /nConstructor of GridView.count: /n``` GridView.count({     Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required int crossAxisCount,     double mainAxisSpacing: 0.0,     double crossAxisSpacing: 0.0,     double childAspectRatio: 1.0,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     List<Widget> children: const <Widget>[],     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge }) ``` /nCreates a scrollable, 2D array of widgets with a fixed number of tiles in the cross axis. Some of the important properties are:  /n+ scrollDirection:It specifies the direction in which GridView will scroll. By default, it scrolls in a vertical direction. /n+ shrinkWrap:If the scroll view does not shrink wrap, then the scroll view will expand to the maximum allowed size in the scrollDirection. If the scroll view has unbounded constraints in the scrollDirection, then shrinkWrap must be true. /n+ crossAxisCount:It specifies the number of columns in a grid view. /n+ crossAxisSpacing:It specifies the spacing between each child widget listed in the cross axis. /n+ mainAxisSpacing:It specifies the number of pixels between each child widget listed in the main axis.  /nExample: /n``` GridView.count( crossAxisCount: 2 , children: List.generate(10,(index){   return Container(     child: Card(       color: Colors.blue,     ),   ); }), ) ``` /n##### ii) GridView.builder /nConstructor: /n``` GridView.builder(     {Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required SliverGridDelegate gridDelegate,     @required IndexedWidgetBuilder itemBuilder,     int itemCount,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge} ) ``` /nCreates a scrollable, 2D array of widgets that are created on demand. This constructor is appropriate for grid views with a large (or infinite) number of children because the builder is called only for those children that are actually visible.  /n+ itemCount:It specifies the item count. /n+ gridDelegate:It determines the grid or its divider. Its argument should not be null. /n+ itemBuilder:It is used to create items that will be displayed on the grid view. It will be called only when the indices >= 0 and indices < itemCount.  /nExample: /n``` final List<String> entries = <String>['A', 'B', 'C', 'D', 'E', 'F'];   GridView.builder(              itemCount: entries.length,              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(                  crossAxisCount: 2,              ),              itemBuilder: (BuildContext context, int index){                return Text('${entries[index]}');              },            ) ``` /n##### iii) GridView.extent() /nCreates a scrollable, 2D array of widgets with tiles that each have a maximum cross-axis extent.  /nConstructor: /n``` GridView.extent(     {Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required double maxCrossAxisExtent,     double mainAxisSpacing: 0.0,     double crossAxisSpacing: 0.0,     double childAspectRatio: 1.0,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     List<Widget> children: const <Widget>[],     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge} ) ``` /nExample: /n``` GridView.extent(            primary: false,            padding: const EdgeInsets.all(16),            crossAxisSpacing: 10,            mainAxisSpacing: 10,            maxCrossAxisExtent: 200.0,            children: <Widget>[              Container(                padding: const EdgeInsets.all(8),                child: const Text('A', style: TextStyle(fontSize: 20)),                color: Colors.orange,              ),              Container(                padding: const EdgeInsets.all(8),                child: const Text('B', style: TextStyle(fontSize: 20)),                color: Colors.blue,              ),              Container(                padding: const EdgeInsets.all(8),                child: const Text('C', style: TextStyle(fontSize: 20)),                color: Colors.blue,              ),              Container(                padding: const EdgeInsets.all(8),                child: const Text('D', style: TextStyle(fontSize: 20)),                color: Colors.orange,              ),            ],          ) ``` /n#### 6) Stack /nStack is useful when you want to overlap multiple children in a single screen. Each member of a Stack widget is either positioned or non-positioned.  /n##### i) Positioned Widget: /nA child of Stack wrapped with Positioned Widget that has at least one non-null property. It works with a combination of parameters - vertical (top, bottom, height) and horizontal (left, right and width) to position the widgets within the Stack. If not positioned widget, Align Widget is used to position the member of Stack.  /n##### ii) Non-positioned Widget: /nIf Stack's member is not wrapped with Align or Positioned Widget, then it is considered a Non-positioned widget. Non-positioned widgets end up on the screen based on Stack's alignment property. By default, the top left corner on the screen.  /nExample: /n``` Stack(   alignment: Alignment.topLeft,   children: <Widget>[     Positioned(       top: 100,       left: 100,       child: Container(         height: 300,         width: 300,         child: Center(child: Text('Positioned')),         color: Colors.orange,       ),     ),     Align(       alignment: Alignment.topCenter,       child: Container(         height: 300,         width: 300,         child: Center(child: Text('Aligned')),         color: Colors.red,       ),     ),     Container(       height: 100,       width: 100,       child: Center(child: Text('Non-Positioned')),         color: Colors.blue,     ),   ], ) ```  #### 1) Row  /nRow is a layout widget in flutter which aligns its children horizontally. It can have multiple child widgets. Child widget can also be a Row or Column widget. Children of Row widget are not scrollable. If you want scrollable widgets then use ListView. If we add a large number of children in Row widget which can not be fit in Row then we see an overflow message.   /nConstructor:  ```  Row({ Key key, MainAxisAlignment mainAxisAlignment: MainAxisAlignment.start,     MainAxisSize mainAxisSize: MainAxisSize.max,     CrossAxisAlignment crossAxisAlignment: CrossAxisAlignment.center,     TextDirection textDirection,     VerticalDirection verticalDirection: VerticalDirection.down,     TextBaseline textBaseline,     List<Widget> children: const [] }) ``` /nmainAxisAlignment property runs horizontally and crossAxisAlignment property runs vertically.  /nHere is different properties explained for main axis and cross axis alignment:  /n+ start: it will align children at the start of the axis direction. /n+ center: It will align children at the center of the axis. /n+ end: It will align children at the end of the axis. /n+ spaceBetween: It will add space between children evenly. /n+ spaceAround:It will add the space between the children evenly and half of that space before and after the first and last children widget. /n+ spaceEvenly: It will add the space between the children evenly and before and after the first and last children widget.  /n#### 2) Column /nColumn is a layout widget in flutter which aligns its children vertically. It can have multiple child widgets. Child widget can also be a Row or Column widget. Children of Column widget are not scrollable. If you want scrollable widgets then use ListView. If we add a large number of children in Column widget which can not be fit in column then we see an overflow message.  /nConstructor: ``` Column(     {Key key,     MainAxisAlignment mainAxisAlignment: MainAxisAlignment.start,     MainAxisSize mainAxisSize: MainAxisSize.max,     CrossAxisAlignment crossAxisAlignment: CrossAxisAlignment.center,     TextDirection textDirection,     VerticalDirection verticalDirection: VerticalDirection.down,     TextBaseline textBaseline,     List<Widget> children: const <Widget>[]} ) ``` /nHere is different properties explained for main axis and cross axis alignment:  /n+ start: it will align children at the start of the axis direction. /n+ center: It will align children at the center of the axis. /n+ end: It will align children at the end of the axis. /n+ spaceBetween: It will add space between children evenly. /n+ spaceAround: It will add the space between the children evenly and half of that space before and after the first and last children widget. /n+ spaceEvenly: It will add the space between the children evenly and before and after the first and last children widget.  /n#### 3) Expanded /nExpanded works with Flex/Flexbox layout and is great for distributing space between multiple items. It expands the child of the Row, Column or Flex widget such that the child fills maximum available space.  /nExample:  /n``` Center(        child: Row(          children: <Widget>[            Container(              color: Colors.blue,              height: 100,              width: 100,            ),            Expanded(              child: Container(                color: Colors.orange,                height: 100,              ),            ),            Container(              color: Colors.blue,              height: 100,              width: 100,            ),          ],        ),    ) ```  /nIf multiple children are expanded, the available space is divided among them according to the flex factor.  /nExample:  /n``` Center(        child: Row(          children: <Widget>[            Expanded(              flex: 2,              child: Container(      color: Colors.blue,      height: 100,      width: 100,            )),            Expanded(              flex: 3,              child: Container(                color: Colors.orange,                height: 100,      width: 100              ),            ),            Expanded(              flex: 4,              child: Container(                color: Colors.blue,                   height: 100,      width: 100              ),            ),          ],        ),    ) ```  /n#### 4) ListView /nA scrollable list of widgets arranged linearly. It shows children one by one in a scrollable direction. when we want to create a list recursively without writing code again and again then ListView.builder is used instead of ListView.  /nConstructor of ListView: /n``` ListView({     Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     double itemExtent,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     List<Widget> children: const <Widget>[],     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge }) ```  /nExample of ListView:  /n``` ListView(        children: <Widget>[          Text('Sunday'),          Text('Monday'),          Text('Tuesday'),        ],      ) ``` /nThe above constructor is useful for a small size of list because it takes List as children. To work with lists having a large number of items, we need to use ListView.builder. The difference between ListView and ListView.builder is that ListView creates all items at once whereas ListView.builder creates items when they are scrolled onto the screen.  /n``` ListView.builder({     Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     double itemExtent,     @required IndexedWidgetBuilder itemBuilder,     int itemCount,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge }) ```  /nThe ListView.builder constructor takes an IndexedWidgetBuilder, which builds the children on demand.  /nExample:  /n``` final List<String> entries = <String>['A', 'B', 'C'];  ListView.builder(        itemCount: entries.length,        itemBuilder: (BuildContext context, int index) {       return Text('${entries[index]}');   } ) ``` /nSimilarly ListView.separated is useful when you want to add a separator in between children of the List.  /nConstructor of ListView.separated:  /n``` ListView.separated({     Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required IndexedWidgetBuilder itemBuilder,     @required IndexedWidgetBuilder separatorBuilder,     @required int itemCount,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge }) ```  /nThe ListView.separated constructor takes two IndexedWidgetBuilders: itemBuilder builds child items on demand, and separatorBuilder similarly builds separator children which appear in between the child items. This constructor is appropriate for list views with a fixed number of children.  /nExample: /n``` final List<String> entries = <String>['A', 'B', 'C'];  ListView.separated(  itemCount: entries.length,  itemBuilder: (BuildContext context, int index) {    return Container(      height: 50,      color: Colors.orange,      child: Center(child: Text('${entries[index]}')),    );  },  separatorBuilder: (BuildContext context, int index) => const Divider(), ); ```  /n##### Horizontal ListView: /nTo create horizontal ListView, specify scrollDirection as horizontal.  /nExample:  /n``` ListView.builder(        scrollDirection: Axis.horizontal,        itemBuilder: (context, index) {          return Container(            margin: const EdgeInsets.symmetric(horizontal: 1.0),            color: Colors.tealAccent,            child: Text('$index'),          );        },      ) ``` /n#### 5) GridView /nGridView is a scrollable 2D array of widgets. The main axis direction of a grid is the direction in which it scrolls. We can define the direction only in which it can scroll using scrollDirection property.  /nThe most frequently used grid layout is GridView.count /n##### i) GridView.count: /nConstructor of GridView.count: /n``` GridView.count({     Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required int crossAxisCount,     double mainAxisSpacing: 0.0,     double crossAxisSpacing: 0.0,     double childAspectRatio: 1.0,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     List<Widget> children: const <Widget>[],     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge }) ``` /nCreates a scrollable, 2D array of widgets with a fixed number of tiles in the cross axis. Some of the important properties are:  /n+ scrollDirection:It specifies the direction in which GridView will scroll. By default, it scrolls in a vertical direction. /n+ shrinkWrap:If the scroll view does not shrink wrap, then the scroll view will expand to the maximum allowed size in the scrollDirection. If the scroll view has unbounded constraints in the scrollDirection, then shrinkWrap must be true. /n+ crossAxisCount:It specifies the number of columns in a grid view. /n+ crossAxisSpacing:It specifies the spacing between each child widget listed in the cross axis. /n+ mainAxisSpacing:It specifies the number of pixels between each child widget listed in the main axis.  /nExample: /n``` GridView.count( crossAxisCount: 2 , children: List.generate(10,(index){   return Container(     child: Card(       color: Colors.blue,     ),   ); }), ) ``` /n##### ii) GridView.builder /nConstructor: /n``` GridView.builder(     {Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required SliverGridDelegate gridDelegate,     @required IndexedWidgetBuilder itemBuilder,     int itemCount,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge} ) ``` /nCreates a scrollable, 2D array of widgets that are created on demand. This constructor is appropriate for grid views with a large (or infinite) number of children because the builder is called only for those children that are actually visible.  /n+ itemCount:It specifies the item count. /n+ gridDelegate:It determines the grid or its divider. Its argument should not be null. /n+ itemBuilder:It is used to create items that will be displayed on the grid view. It will be called only when the indices >= 0 and indices < itemCount.  /nExample: /n``` final List<String> entries = <String>['A', 'B', 'C', 'D', 'E', 'F'];   GridView.builder(              itemCount: entries.length,              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(                  crossAxisCount: 2,              ),              itemBuilder: (BuildContext context, int index){                return Text('${entries[index]}');              },            ) ``` /n##### iii) GridView.extent() /nCreates a scrollable, 2D array of widgets with tiles that each have a maximum cross-axis extent.  /nConstructor: /n``` GridView.extent(     {Key key,     Axis scrollDirection: Axis.vertical,     bool reverse: false,     ScrollController controller,     bool primary,     ScrollPhysics physics,     bool shrinkWrap: false,     EdgeInsetsGeometry padding,     @required double maxCrossAxisExtent,     double mainAxisSpacing: 0.0,     double crossAxisSpacing: 0.0,     double childAspectRatio: 1.0,     bool addAutomaticKeepAlives: true,     bool addRepaintBoundaries: true,     bool addSemanticIndexes: true,     double cacheExtent,     List<Widget> children: const <Widget>[],     int semanticChildCount,     DragStartBehavior dragStartBehavior: DragStartBehavior.start,     ScrollViewKeyboardDismissBehavior keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.manual,     String restorationId,     Clip clipBehavior: Clip.hardEdge} ) ``` /nExample: /n``` GridView.extent(            primary: false,            padding: const EdgeInsets.all(16),            crossAxisSpacing: 10,            mainAxisSpacing: 10,            maxCrossAxisExtent: 200.0,            children: <Widget>[              Container(                padding: const EdgeInsets.all(8),                child: const Text('A', style: TextStyle(fontSize: 20)),                color: Colors.orange,              ),              Container(                padding: const EdgeInsets.all(8),                child: const Text('B', style: TextStyle(fontSize: 20)),                color: Colors.blue,              ),              Container(                padding: const EdgeInsets.all(8),                child: const Text('C', style: TextStyle(fontSize: 20)),                color: Colors.blue,              ),              Container(                padding: const EdgeInsets.all(8),                child: const Text('D', style: TextStyle(fontSize: 20)),                color: Colors.orange,              ),            ],          ) ``` /n#### 6) Stack /nStack is useful when you want to overlap multiple children in a single screen. Each member of a Stack widget is either positioned or non-positioned.  /n##### i) Positioned Widget: /nA child of Stack wrapped with Positioned Widget that has at least one non-null property. It works with a combination of parameters - vertical (top, bottom, height) and horizontal (left, right and width) to position the widgets within the Stack. If not positioned widget, Align Widget is used to position the member of Stack.  /n##### ii) Non-positioned Widget: /nIf Stack's member is not wrapped with Align or Positioned Widget, then it is considered a Non-positioned widget. Non-positioned widgets end up on the screen based on Stack's alignment property. By default, the top left corner on the screen.  /nExample: /n``` Stack(   alignment: Alignment.topLeft,   children: <Widget>[     Positioned(       top: 100,       left: 100,       child: Container(         height: 300,         width: 300,         child: Center(child: Text('Positioned')),         color: Colors.orange,       ),     ),     Align(       alignment: Alignment.topCenter,       child: Container(         height: 300,         width: 300,         child: Center(child: Text('Aligned')),         color: Colors.red,       ),     ),     Container(       height: 100,       width: 100,       child: Center(child: Text('Non-Positioned')),         color: Colors.blue,     ),   ], ) ```